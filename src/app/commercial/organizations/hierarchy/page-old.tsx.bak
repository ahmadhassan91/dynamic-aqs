'use client';

import { useState, useEffect } from 'react';
import {
  Container,
  Title,
  Text,
  Stack,
  Card,
  Group,
  Badge,
  Button,
  ActionIcon,
  Box,
  Collapse,
  Alert,
  Loader,
  Grid,
  Paper,
  Divider,
  ThemeIcon,
  ScrollArea,
  rem
} from '@mantine/core';
import {
  IconBuilding,
  IconChevronRight,
  IconChevronDown,
  IconAlertCircle,
  IconCheck,
  IconX,
  IconMapPin,
  IconPhone,
  IconMail,
  IconUser,
  IconCalendar,
  IconBuildingFactory2,
  IconTool,
  IconHome,
  IconRuler,
  IconWreckingBall,
  IconSettings
} from '@tabler/icons-react';
import { CommercialLayout } from '@/components/layout/CommercialLayout';
import { Organization, OrganizationType } from '@/types/commercial';
import { commercialService } from '@/lib/services/commercialService';

interface OrganizationNode extends Organization {
  children: OrganizationNode[];
  level: number;
  isExpanded: boolean;
}

interface ValidationError {
  type: 'circular_reference' | 'invalid_parent' | 'max_depth_exceeded';
  message: string;
  organizationId: string;
}

export default function OrganizationHierarchyPage() {
  const [organizations, setOrganizations] = useState<Organization[]>([]);
  const [hierarchyTree, setHierarchyTree] = useState<OrganizationNode[]>([]);
  const [loading, setLoading] = useState(true);
  const [selectedOrganization, setSelectedOrganization] = useState<Organization | null>(null);
  const [expandedNodes, setExpandedNodes] = useState<Set<string>>(new Set());
  const [validationErrors, setValidationErrors] = useState<ValidationError[]>([]);
  const [isEditMode, setIsEditMode] = useState(false);
  useEffect(() => {
    loadOrganizations();
  }, []);

  const loadOrganizations = async () => {
    try {
      setLoading(true);
      const data = await commercialService.getOrganizations();
      setOrganizations(data);
      buildHierarchyTree(data);
      validateHierarchy(data);
    } catch (error) {
      console.error('Error loading organizations:', error);
    } finally {
      setLoading(false);
    }
  };

  const buildHierarchyTree = (orgs: Organization[]) => {
    const orgMap = new Map<string, OrganizationNode>();
    const rootNodes: OrganizationNode[] = [];

    // Create nodes
    orgs.forEach(org => {
      orgMap.set(org.id, {
        ...org,
        children: [],
        level: 0,
        isExpanded: expandedNodes.has(org.id)
      });
    });

    // Build hierarchy
    orgs.forEach(org => {
      const node = orgMap.get(org.id)!;
      if (org.parentId && orgMap.has(org.parentId)) {
        const parent = orgMap.get(org.parentId)!;
        parent.children.push(node);
        node.level = parent.level + 1;
      } else {
        rootNodes.push(node);
      }
    });

    // Sort nodes by name
    const sortNodes = (nodes: OrganizationNode[]) => {
      nodes.sort((a, b) => a.name.localeCompare(b.name));
      nodes.forEach(node => sortNodes(node.children));
    };
    sortNodes(rootNodes);

    setHierarchyTree(rootNodes);
  };

  const validateHierarchy = (orgs: Organization[]) => {
    const errors: ValidationError[] = [];
    const visited = new Set<string>();
    const recursionStack = new Set<string>();

    const detectCircularReference = (orgId: string, path: string[] = []): boolean => {
      if (recursionStack.has(orgId)) {
        errors.push({
          type: 'circular_reference',
          message: `Circular reference detected in path: ${path.join(' -> ')} -> ${orgId}`,
          organizationId: orgId
        });
        return true;
      }

      if (visited.has(orgId)) {
        return false;
      }

      visited.add(orgId);
      recursionStack.add(orgId);

      const org = orgs.find(o => o.id === orgId);
      if (org?.parentId) {
        const newPath = [...path, org.name];
        if (detectCircularReference(org.parentId, newPath)) {
          return true;
        }
      }

      recursionStack.delete(orgId);
      return false;
    };

    // Check for circular references and max depth
    orgs.forEach(org => {
      if (!visited.has(org.id)) {
        detectCircularReference(org.id);
      }

      // Check max depth (e.g., 5 levels)
      let depth = 0;
      let currentOrg = org;
      const pathIds = new Set<string>();
      
      while (currentOrg.parentId && depth < 10) {
        if (pathIds.has(currentOrg.id)) {
          break; // Circular reference already detected
        }
        pathIds.add(currentOrg.id);
        currentOrg = orgs.find(o => o.id === currentOrg.parentId) || currentOrg;
        depth++;
      }

      if (depth >= 5) {
        errors.push({
          type: 'max_depth_exceeded',
          message: `Organization hierarchy exceeds maximum depth of 5 levels`,
          organizationId: org.id
        });
      }
    });

    setValidationErrors(errors);
  };



  const toggleExpansion = (nodeId: string) => {
    const newExpanded = new Set(expandedNodes);
    if (newExpanded.has(nodeId)) {
      newExpanded.delete(nodeId);
    } else {
      newExpanded.add(nodeId);
    }
    setExpandedNodes(newExpanded);
    buildHierarchyTree(organizations);
  };

  const handleOrganizationClick = (organization: Organization) => {
    setSelectedOrganization(organization);
  };

  const getOrganizationColor = (type: OrganizationType) => {
    const colors: Record<OrganizationType, string> = {
      [OrganizationType.ENGINEERING_FIRM]: 'blue',
      [OrganizationType.MANUFACTURER_REP]: 'green',
      [OrganizationType.BUILDING_OWNER]: 'orange',
      [OrganizationType.ARCHITECT]: 'purple',
      [OrganizationType.MECHANICAL_CONTRACTOR]: 'teal',
      [OrganizationType.FACILITIES_MANAGER]: 'cyan'
    };
    return colors[type] || 'gray';
  };

  const renderHierarchyNode = (node: OrganizationNode) => {
    const hasChildren = node.children.length > 0;
    const isExpanded = expandedNodes.has(node.id);
    const isSelected = selectedOrganization?.id === node.id;
    const hasError = validationErrors.some(error => error.organizationId === node.id);

    return (
      <Box key={node.id}>
        <Paper
          p="xs"
          withBorder={isSelected}
          style={{
            marginLeft: node.level * 24,
            cursor: 'pointer',
            backgroundColor: isSelected 
              ? 'var(--mantine-color-blue-0)' 
              : hasError
              ? 'var(--mantine-color-red-0)'
              : undefined,
            borderColor: isSelected 
              ? 'var(--mantine-color-blue-3)' 
              : hasError
              ? 'var(--mantine-color-red-3)'
              : undefined,
            transition: 'all 0.2s ease'
          }}
          onClick={() => handleOrganizationClick(node)}
        >
          <Group wrap="nowrap" gap="xs">
            {isEditMode && (
              <ActionIcon size="sm" variant="subtle" color="gray">
                <IconGripVertical size={14} />
              </ActionIcon>
            )}
            
            {hasChildren ? (
              <ActionIcon
                size="sm"
                variant="subtle"
                onClick={(e) => {
                  e.stopPropagation();
                  toggleExpansion(node.id);
                }}
              >
                {isExpanded ? <IconChevronDown size={16} /> : <IconChevronRight size={16} />}
              </ActionIcon>
            ) : (
              <Box w={24} />
            )}
            
            <ThemeIcon size="sm" radius="sm" variant="light" color={getOrganizationColor(node.type)}>
              <IconBuilding size={14} />
            </ThemeIcon>
            
            <Box style={{ flex: 1, minWidth: 0 }}>
              <Group justify="space-between" wrap="nowrap">
                <Box style={{ minWidth: 0, flex: 1 }}>
                  <Text size="sm" fw={500} truncate>
                    {node.name}
                  </Text>
                  <Text size="xs" c="dimmed">
                    {node.type}
                  </Text>
                </Box>
                <Group gap={4} wrap="nowrap">
                  {hasError && (
                    <Badge size="sm" color="red" variant="light">
                      Error
                    </Badge>
                  )}
                  {!node.isActive && (
                    <Badge size="sm" color="red" variant="light">
                      Inactive
                    </Badge>
                  )}
                  {hasChildren && (
                    <Badge size="sm" color="gray" variant="light">
                      {node.children.length}
                    </Badge>
                  )}
                </Group>
              </Group>
            </Box>
          </Group>
        </Paper>
        
        {hasChildren && isExpanded && (
          <Collapse in={isExpanded}>
            <Stack gap="xs" mt="xs">
              {node.children.map((child) => renderHierarchyNode(child))}
            </Stack>
          </Collapse>
        )}
      </Box>
    );
  };

  const renderValidationErrors = () => {
    if (validationErrors.length === 0) return null;

    return (
      <Alert 
        icon={<IconAlertCircle size={16} />} 
        title="Hierarchy Validation Errors" 
        color="red"
        variant="light"
      >
        <Stack gap="xs">
          {validationErrors.map((error, index) => (
            <Text key={index} size="sm">
              • {error.message}
            </Text>
          ))}
        </Stack>
      </Alert>
    );
  };

  const renderOrganizationDetails = () => {
    if (!selectedOrganization) {
      return (
        <Stack align="center" justify="center" py={60}>
          <ThemeIcon size={60} radius="xl" color="gray" variant="light">
            <IconBuilding size={32} />
          </ThemeIcon>
          <Text c="dimmed" size="sm">
            Select an organization to view details
          </Text>
        </Stack>
      );
    }

    const orgErrors = validationErrors.filter(error => error.organizationId === selectedOrganization.id);

    return (
      <Stack gap="lg">
        {/* Header */}
        <Group>
          <ThemeIcon size="xl" radius="md" variant="light" color={getOrganizationColor(selectedOrganization.type)}>
            <IconBuilding size={24} />
          </ThemeIcon>
          <div>
            <Title order={4}>{selectedOrganization.name}</Title>
            <Text size="sm" c="dimmed">{selectedOrganization.type}</Text>
          </div>
        </Group>

        {/* Validation Errors */}
        {orgErrors.length > 0 && (
          <Alert icon={<IconAlertCircle size={16} />} title="Validation Issues" color="red" variant="light">
            <Stack gap="xs">
              {orgErrors.map((error, index) => (
                <Text key={index} size="sm">• {error.message}</Text>
              ))}
            </Stack>
          </Alert>
        )}

        <Divider />

        {/* Contact Information */}
        <div>
          <Title order={5} mb="sm">Contact Information</Title>
          <Stack gap="xs">
            <Group gap="xs">
              <IconUser size={16} />
              <Text size="sm">
                {selectedOrganization.contactInfo.firstName} {selectedOrganization.contactInfo.lastName}
              </Text>
            </Group>
            <Group gap="xs">
              <IconMail size={16} />
              <Text size="sm">{selectedOrganization.contactInfo.email}</Text>
            </Group>
            <Group gap="xs">
              <IconPhone size={16} />
              <Text size="sm">{selectedOrganization.contactInfo.phone}</Text>
            </Group>
            {selectedOrganization.contactInfo.title && (
              <Group gap="xs">
                <IconUser size={16} />
                <Text size="sm">{selectedOrganization.contactInfo.title}</Text>
              </Group>
            )}
          </Stack>
        </div>

        {/* Address */}
        {selectedOrganization.contactInfo.address && (
          <>
            <Divider />
            <div>
              <Title order={5} mb="sm">Address</Title>
              <Group gap="xs" align="flex-start">
                <IconMapPin size={16} style={{ marginTop: 2 }} />
                <Stack gap={0}>
                  <Text size="sm">{selectedOrganization.contactInfo.address.street}</Text>
                  <Text size="sm">
                    {selectedOrganization.contactInfo.address.city}, {selectedOrganization.contactInfo.address.state} {selectedOrganization.contactInfo.address.zipCode}
                  </Text>
                  <Text size="sm">{selectedOrganization.contactInfo.address.country}</Text>
                </Stack>
              </Group>
            </div>
          </>
        )}

        <Divider />

        {/* Organization Details */}
        <div>
          <Title order={5} mb="sm">Organization Details</Title>
          <Grid gutter="xs">
            <Grid.Col span={6}>
              <Text size="xs" c="dimmed">Status</Text>
              <Badge 
                color={selectedOrganization.isActive ? 'green' : 'red'} 
                variant="light"
                leftSection={selectedOrganization.isActive ? <IconCheck size={12} /> : <IconX size={12} />}
              >
                {selectedOrganization.isActive ? 'Active' : 'Inactive'}
              </Badge>
            </Grid.Col>
            <Grid.Col span={6}>
              <Text size="xs" c="dimmed">Created</Text>
              <Group gap={4}>
                <IconCalendar size={14} />
                <Text size="sm">{selectedOrganization.createdAt.toLocaleDateString()}</Text>
              </Group>
            </Grid.Col>
            {selectedOrganization.territoryId && (
              <Grid.Col span={6}>
                <Text size="xs" c="dimmed">Territory</Text>
                <Text size="sm">{selectedOrganization.territoryId}</Text>
              </Grid.Col>
            )}
            <Grid.Col span={6}>
              <Text size="xs" c="dimmed">Last Updated</Text>
              <Text size="sm">{selectedOrganization.updatedAt.toLocaleDateString()}</Text>
            </Grid.Col>
          </Grid>
        </div>

        {/* Hierarchy */}
        {selectedOrganization.parentId && (
          <>
            <Divider />
            <div>
              <Title order={5} mb="sm">Hierarchy</Title>
              <Text size="sm" c="dimmed">Parent Organization ID:</Text>
              <Text size="sm" fw={500}>{selectedOrganization.parentId}</Text>
            </div>
          </>
        )}
      </Stack>
    );
  };

  if (loading) {
    return (
      <CommercialLayout>
        <Container size="xl" py="md">
          <Stack align="center" justify="center" style={{ minHeight: 400 }}>
            <Loader size="lg" />
            <Text c="dimmed">Loading organization hierarchy...</Text>
          </Stack>
        </Container>
      </CommercialLayout>
    );
  }

  return (
    <CommercialLayout>
      <Container size="xl" py="md">
        <Stack gap="lg">
          {/* Header */}
          <Group justify="space-between" align="flex-start">
            <div>
              <Title order={1}>Organization Hierarchy</Title>
              <Text size="sm" c="dimmed" mt={4}>
                Manage organization relationships and structure
              </Text>
            </div>
            <Button
              leftSection={isEditMode ? <IconX size={16} /> : <IconEdit size={16} />}
              onClick={() => setIsEditMode(!isEditMode)}
              color={isEditMode ? 'red' : 'blue'}
              variant={isEditMode ? 'light' : 'filled'}
            >
              {isEditMode ? 'Exit Edit Mode' : 'Edit Hierarchy'}
            </Button>
          </Group>

          {/* Validation Errors */}
          {renderValidationErrors()}

          {/* Main Grid */}
          <Grid gutter="md">
            <Grid.Col span={{ base: 12, lg: 6 }}>
              <Card withBorder shadow="sm" padding="lg" radius="md">
                <Card.Section withBorder p="md">
                  <Title order={3}>Organization Structure</Title>
                  <Text size="sm" c="dimmed" mt={4}>
                    {isEditMode 
                      ? 'Drag and drop to reorganize hierarchy' 
                      : 'Click to expand/collapse, select to view details'
                    }
                  </Text>
                </Card.Section>

                <Card.Section p="md" style={{ maxHeight: 600, overflowY: 'auto' }}>
                  {hierarchyTree.length > 0 ? (
                    <Stack gap="xs">
                      {hierarchyTree.map((node) => 
                        renderHierarchyNode(node)
                      )}
                    </Stack>
                  ) : (
                    <Stack align="center" py={60}>
                      <ThemeIcon size="xl" radius="xl" color="gray" variant="light">
                        <IconBuilding size={24} />
                      </ThemeIcon>
                      <Text c="dimmed" size="sm">No organizations found</Text>
                    </Stack>
                  )}
                </Card.Section>
              </Card>
            </Grid.Col>

            <Grid.Col span={{ base: 12, lg: 6 }}>
              <Card withBorder shadow="sm" padding="lg" radius="md" style={{ position: 'sticky', top: 20 }}>
                <Card.Section withBorder p="md">
                  <Title order={3}>Organization Details</Title>
                </Card.Section>

                <Card.Section p="md" style={{ maxHeight: 600, overflowY: 'auto' }}>
                  {renderOrganizationDetails()}
                </Card.Section>
              </Card>
            </Grid.Col>
          </Grid>
        </Stack>
      </Container>
    </CommercialLayout>
  );
}